name: Hado Ruleset
rules:
  - scope: output
    category: Negative
    instruction: |
      nodes = command_util.get_every_node_of_instruction("WORKDIR")
      for node in nodes:
        p = command_util.get_node_property_string(node, "Path")
        assert(p.startswith("/") or p.startswith("$"))
    description: Use absolute workdir
    id: DL3000 
    target: command

  - scope: output
    category: Negative
    instruction: |
      assert(not command_util.uses_command("sudo"))
    description: No sud)o
    id: DL3004
    target: command

  - scope: output
    category: Negative
    instruction: |
      nodes = command_util.get_every_node_of_instruction("EXPOSE")
      for node in nodes:
        ports = command_util.get_expose_node_port_numbers(node)
        assert(all([p >= 0 and p <= 65535 for p in ports]))
    id: DL3011
    target: command
    description: Valid unix ports in expose

  - scope: output
    category: Negative
    instruction: |
      assert(len(command_util.get_every_node_of_instruction("HEALTHCHECK")) <= 1)
    id: DL3012
    target: command

  - scope: output
    category: Negative
    instruction: |
      def is_allowed(source):
        # url is allowed
        source = source.replace('"', "")
        if source.startswith("http://") or source.startswith("https://"):
          return True
        # repo is allowed
        if source.startswith("git@"):
          return True
        if source.endswith(".tar.gz") or source.endswith(".tar.xz") or source.endswith(".gz") or source.endswith(".zip"):
          return True
        return False

      nodes = command_util.get_every_node_of_instruction("ADD")
      for node in nodes:
        sources = command_util.get_node_property_string_list(node, "Source")
        assert(all([is_allowed(source) for source in sources]))
    id: DL3020
    description: Only use add for url, repo and archives
    target: command

  - scope: output
    category: Negative
    instruction: |
      nodes = command_util.get_every_node_of_instruction("COPY")
      for node in nodes:
        sources = command_util.get_node_property_string_list(node, "Source")
        if len(sources) == 1:
          continue
        destination = command_util.get_node_property_string(node, "Destination")
        assert(destination.endswith("/"))
    id: DL3021
    target: command
    description: Copy with more than 2 sources must end in /

  - scope: output
    category: Negative
    instruction: |
      ast_depth = command_util.get_ast_depth()
      for level in range(ast_depth):
        nodes = command_util.get_every_node_of_instruction_at_level(level, "COPY")
        if len(nodes) == 0:
          continue
        stage_node = command_util.get_stage_node_at(level)
        stage_name = command_util.get_stage_name(stage_node)
        if len(stage_name) == 0:
          continue
        for node in nodes:
          copy_from = command_util.get_node_property_string(node, "From")
          if len(copy_from) == 0:
            continue
          assert(not stage_name == copy_from)
    id: DL3023
    target: command
    description: FROM should not reference own stage

  - scope: output
    category: Negative
    instruction: |
        seen = set()
        ast_depth = command_util.get_ast_depth()
        for i in range(ast_depth):
          stage_node = command_util.get_stage_node_at(i)
          stage_name = command_util.get_stage_name(stage_node)
          # Emtpy is allowed
          if len(stage_name) == 0:
            continue
          assert(stage_name not in seen)
          seen.add(stage_name)
    id: DL3024
    target: command
    description: stage names must be unique

  - scope: output
    category: Negative
    instruction: |
      def allowed(key, value):
        # fstrings dont work here in this environment for some reason
        if "${"+key+"}" in value:
          return False
        if f"${key}" not in value:
          return True
        # contains the variable without extension 
        # or a variable with the key as prefix?
        if value.endswith(f"${key}"):
          return False
        print(f"Char: {value[value.find(f"${key}") + len(key) + 1]}")
        return value[value.find(f"${key}") + len(key) + 1] != " "

      nodes = command_util.get_every_node_of_instruction("ENV")
      for node in nodes:
        keys = command_util.get_node_property_string_map_keys(node, "Pairs")
        for key in keys:
          for lookup in keys:
            if lookup == key:
              continue
            assert(allowed(key, command_util.get_node_property_string_map_value(node, "Pairs", lookup)))
    id: DL3044
    target: command
    description: env should not reference self

  - scope: output
    category: Negative
    instruction: |
      nodes = command_util.get_every_node_of_instruction("MAINTAINER")
      assert(len(nodes) == 0)
    id: DL4000
    target: command
    description: No MAINTAINER due to deprecation

  - scope: output
    category: Negative
    instruction: |
      nodes = command_util.get_every_node_of_instruction("ENTRYPOINT")
      assert(len(nodes) <= 1)
    id: DL4004
    target: command
    description: Only one entrypoint

  - scope: output
    category: Negative
    instruction: |
      forbidden_list = ["ONBUILD", "FROM", "MAINTAINER"]
      nodes = command_util.get_every_node_of_instruction("ONBUILD")
      for node in nodes:
        instruction = command_util.get_instruction_from_onbuild(node)
        assert(command_util.get_node_instruction_string(instruction) not in forbidden_list)
    id: DL4004
    target: command
    description: Onbuild, from and maintainer are not allowed in onbuild
